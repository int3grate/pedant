################################################################################
# Copyright (c) 2011, Mak Kolybabi
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
################################################################################

class Pedant::Nasl::Grammar

preclow
  right ASS_EQ ADD_EQ SUB_EQ MUL_EQ DIV_EQ MOD_EQ SLL_EQ SRA_EQ SRL_EQ
  left OR
  left AND
  left CMP_LT CMP_GT CMP_EQ CMP_NE CMP_GE CMP_LE SUBSTR_EQ SUBSTR_NE REGEX_EQ REGEX_NE
  left BIT_OR
  left BIT_XOR
  left BIT_AND
  left BIT_SRA BIT_SRL BIT_SLL
  left ADD SUB
  left MUL DIV MOD
  right NOT
  right UMINUS BIT_NOT
  right EXP
  right INCR DECR
prechigh

# Tell the parser generator that we don't wish to use the result variable in the
# action section of rules. Instead, the result of the rule will be the value of
# evaluating the action block.
options no_result_var

# Tell the parser generator that we expect one shift/reduce conflict due to
# the well-known dangling else problem. We could make the grammar solve this
# problem, but this is how the NASL YACC file solves it, so we'll follow suit.
expect 1

rule
  ##############################################################################
  # Aggregate Statements
  ##############################################################################

  start      : roots
             { val[0] }
             | /* Blank */
             { [] }
             ;

  roots      : root roots
             { [val[0]] + val[1] }
             | root
             { [val[0]] }
             ;

  root       : export
             { val[0] }
             | function
             { val[0] }
             | statement
             { val[0] }
             ;

  statement  : simple ';'
             { val[0] }
             | compound
             { val[0] }
             ;

  ##############################################################################
  # Root Statements
  ##############################################################################

  export     : EXPORT function
             { n(:Export, val[1]) }
             ;

  function   : FUNCTION ident '(' params ')' block
             { n(:Function, val[1], val[3], val[5]) }
             | FUNCTION ident '(' ')' block
             { n(:Function, val[1], [], val[4]) }
             ;

  simple     : assign
             { val[0] }
             | break
             { val[0] }
             | call
             { val[0] }
             | continue
             { val[0] }
             | decr
             { val[0] }
             | empty
             { val[0] }
             | global
             { val[0] }
             | import
             { val[0] }
             | include
             { val[0] }
             | incr
             { val[0] }
             | local
             { val[0] }
             | rep
             { val[0] }
             | return
             { val[0] }
             ;

  compound   : block
             { val[0] }
             | for
             { val[0] }
             | foreach
             { val[0] }
             | if
             { val[0] }
             | repeat
             { val[0] }
             | while
             { val[0] }
             ;

  ##############################################################################
  # Simple Statements
  ##############################################################################

  assign     : lval ASS_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval ADD_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval SUB_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval MUL_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval DIV_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval MOD_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval SRL_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval SRA_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             | lval SLL_EQ expr
             { n(:Assignment, val[0], val[1], val[2]) }
             ;

  break      : BREAK
             { n(:Break) }
             ;

  call       : ident '(' args ')'
             { n(:Call, val[0], val[2]) }
             | ident '(' ')'
             { n(:Call, val[0], []) }
             ;

  continue   : CONTINUE
             { n(:Continue) }
             ;

  decr       : DECR lval
             { n(:Decrement, val[1], :pre) }
             | lval DECR
             { n(:Decrement, val[0], :post) }
             ;

  empty      : /* Blank */
             { n(:Empty) }
             ;

  global     : GLOBAL idents
             { n(:Global, val[1]) }
             ;

  incr       : INCR lval
             { n(:Increment, val[1], :pre) }
             | lval INCR
             { n(:Increment, val[0], :post) }
             ;

  import     : IMPORT '(' string ')'
             { n(:Import, val[2]) }
             ;

  include    : INCLUDE '(' string ')'
             { n(:Include, val[2]) }
             ;

  local      : LOCAL idents
             { n(:Local, val[1]) }
             ;

  rep        : call REP expr
             { n(:Repetition, val[0], val[2]) }
             ;

  return     : RETURN expr
             { n(:Return, val[1]) }
             | RETURN
             { n(:Return, nil) }
             ;

  ##############################################################################
  # Compound Statements
  ##############################################################################

  block      : '{' statements '}'
             { n(:Block, val[1]) }
             | '{' '}'
             { n(:Block, []) }
             ;

  for        : FOR '(' field ';' expr ';' field ')' statement
             { n(:For, val[1], val[4], val[6], val[8]) }
             ;

  foreach    : FOREACH ident '(' expr ')' statement
             { n(:Foreach, val[1], val[3], val[5]) }
             ;

  if         : IF '(' expr ')' statement
             { n(:If, val[2], val[4], nil) }
             | IF '(' expr ')' statement ELSE statement
             { n(:If, val[2], val[4], val[6]) }
             ;

  repeat     : REPEAT statement UNTIL expr ';'
             { n(:Repeat, val[1], val[3]) }
             ;

  while      : WHILE '(' expr ')' statement
             { n(:While, val[2], val[4]) }
             ;

  ##############################################################################
  # Expressions
  ##############################################################################

  expr       : '(' expr ')'
             { val[1] }
             | expr AND expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | NOT expr
             { n(:UnaryExpression, val[0], val[1]) }
             | expr OR expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr ADD expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr SUB expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | SUB expr =UMINUS
             { n(:UnaryExpression, val[0], val[1]) }
             | BIT_NOT expr
             { n(:UnaryExpression, val[0], val[1]) }
             | expr MUL expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr EXP expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr DIV expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr MOD expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr BIT_AND expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr BIT_XOR expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr BIT_OR expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr BIT_SRA expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr BIT_SRL expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr BIT_SLL expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | incr
             { val[0] }
             | decr
             { val[0] }
             | expr SUBSTR_EQ expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr SUBSTR_NE expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr REGEX_EQ expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr REGEX_NE expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr CMP_LT expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr CMP_GT expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr CMP_EQ expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr CMP_NE expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr CMP_GE expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | expr CMP_LE expr
             { n(:BinaryExpression, val[0], val[1], val[2]) }
             | assign
             { val[0] }
             | string
             { val[0] }
             | call
             { val[0] }
             | lval
             { val[0] }
             | ip
             { val[0] }
             | int
             { val[0] }
             | undef
             { val[0] }
             ;

  ##############################################################################
  # Named Components
  ##############################################################################

  arg        : ident ':' expr
             { n(:Argument, val[0], val[2], :named) }
             | expr
             { n(:Argument, nil, val[0], :anonymous) }
             ;

  lval       : ident indexes
             { n(:Lvalue, val[0], val[1]) }
             | ident
             { n(:Lvalue, val[0], []) }
             ;

  ##############################################################################
  # Anonymous Components
  ##############################################################################

  args       : arg ',' args
             { [val[0]] + val[2] }
             | arg
             { [val[0]] }
             ;

  field      : assign
             { val[0] }
             | call
             { val[0] }
             | decr
             { val[0] }
             | incr
             { val[0] }
             | /* Blank */
             { nil }
             ;

  idents     : ident ',' idents
             { [val[0]] + val[2] }
             | ident
             { [val[0]] }
             ;

  indexes    : '[' expr ']' indexes
             { [val[1]] + val[3] }
             | '[' expr ']'
             { [val[1]] }
             ;

  params     : ident ',' params
             { [val[0]] + val[2] }
             | ident
             { [val[0]] }
             ;

  statements : statement statements
             { [val[0]] + val[1] }
             | statement
             { [val[0]] }
             ;

  ##############################################################################
  # Literals
  ##############################################################################

  ident      : IDENT
             { n(:Identifier, val[0]) }
             | REP
             { n(:Identifier, val[0]) }
             ;

  int        : DEC_INT
             { n(:Integer, val[0], 10) }
             | HEX_INT
             { n(:Integer, val[0], 16) }
             | OCT_INT
             { n(:Integer, val[0], 8) }
             | FALSE
             { n(:Integer, '0', 10) }
             | TRUE
             { n(:Integer, '1', 10) }
             ;

  ip         : int '.' int '.' int '.' int
             { n(:Ip, val[0], val[2], val[4], val[6]) }

  string     : DATA
             { n(:String, val[0][1..-2], :pure) }
             | STRING
             { n(:String, val[0][1..-2], :impure) }
             ;

  undef      : UNDEF
             { n(:Undefined) }
             ;
end

---- header ----

require 'lib/pedant/nasl.rex'
require 'lib/pedant/nasl'

---- inner ----

# Generates nodes.
def n(cls, *args)
  Pedant::Nasl.const_get(cls).new(@tree, *args)
end

# Create a parse tree.
def parse(code)
  @tree = Pedant::Nasl::Tree.new
  @tree << scan_str(code)
  @tree.flatten!

  @tree
end

---- footer ----
